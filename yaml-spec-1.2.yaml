#===============================================================================
#
# This YAML grammar was generated from https://yaml.org/spec/1.2/spec.html by:
# https://github.com/yaml/yaml-grammar/tree/master/bin/yaml-grammar-html-to-yaml
#
# This grammar is a YAML file that should be loadable by any decent existing
# YAML loader. It has also been converted to JSON in a file next to this one.
# The YAML file has lots of helpful comments. The JSON (of course) does not.
#
# The purpose of this grammar-as-yaml file is to:
# * Make the spec clearer and more precise to people implementing YAML parsers
# * To generate 100% correct YAML parsers in most programming languages
#
# This grammar mirrors the 1.2 spec faithfully, but tries to express the rules
# in a more concrete and programatic fashion. Some of the rules that are more
# difficult to understand have a comment section before them. Each rule
# definition is preceded by the original YAML 1.2 spec rule text, formatted as
# a comment.
#
#===============================================================================

#===============================================================================
#
#   = Syntax Guide =
#
# The following is an explanation of the various EBNF/DSL syntax forms used in
# this grammar. The original YAML 1.2 spec uses an EBNF form that has more than
# a couple oddities. This file tries to make as much sense of them as possible.
# Each rule that introduces a new syntax is preceded by an explanation.
#
# There are 211 rules in the YAML 1.2 spec. This grammar file has 211 sections,
# one for each rule. The overall structure of this file is a big mapping with
# 2 mapping pairs for each grammar rule. Each rule group looks like this:
#
#   :rule-number: rule-name
#   # original-spec-rule-as-a-comment
#
#   rule-name: rule-definition
#
# The first pair is just for indexing the rule (by rule number) back to the 1.2
# spec. The rule definition is the important part. Complex definitions are data
# structures mostly comprised of other rule-names. The simplest rules point to
# single characters. This forms a top-down grammar where the top is the last
# rule, #211.
#
#
#   == Rule Names ==
#
# A rule name consists of groups of lower case characters and numbers separated
# by dashes (`-`).
#
# Each rule name has a 1 or 2 character prefix indicating the rule type.
#
# Example rule names:
#
#   * nb-foo-bar
#   * nb-foo-bar
#   * nb-foo-bar(n)
#   * nb-foo-bar(n,c)
#
#   === Rule Name Prefixes ===
#
# The rule type prefixes are:
#
#   e  -- Empty (matches no characters)
#   c  -- Character (match one single character)
#   b  -- Break (match a single line break character)
#   nb -- Non-break (match a single non-break character)
#   s  -- Space (match a single whitespace character)
#   ns -- Non-space (match a single non-space character)
#   l  -- Line (match a complete line)
#
# And also (where X and Y are each one of the above prefixes):
#
#   X-Y  -- Match starting with an X- match and ending with a Y- match
#   X+   -- Match X where indentation is greater than n
#   X-Y+ -- Match X-Y where indentation is greater than n
#
#
#   == Rules Variables ==
#
# Some rules are defined with variable arguments indicating that they should be
# passed values when being used. There are 4 distinct variables used in the
# YAML 1.2 grammar.
#
#   n -- Current indentation level. An integer indicating the number of spaces.
#
#   m -- Additional indentation level. An integer indicating number of spaces.
#
#   c -- Current context. String that is one of:
#     * "block-in"
#     * "block-out"
#     * "block-key"
#     * "flow-in"
#     * "flow-out"
#     * "flow-key"
#
#   t -- How to treat whitespace after a literal scalar. One of:
#     * "strip"
#     * "clip"
#     * "keep"
#
# Where and how these variables are set is a bit inconsistent. Some are set by
# explicitly in rules that act like function calls. For example, The starting
# values of n (-1) and c ("block-in") are set in rule 207.
#
# The m variable is set explicitly in rules 183 and 187, albeit by an undefined
# special rule called <auto-detect-indent>. In rules like 185 it assumes that m
# is stored as a state/stack variable and has been set somewhere else.
#
# The t variable is set using functional constructs in rule 164, depending on
# the value of a c-chomping-indicator rule.
#
#
#   == Special Rule Names ==
#
# A handful of rule names are words inside angle brackets. These are called
# "special rules". They are not defined in the grammar. Each of these rules is
# an assertion that doesn't consume any text in the parse. They are:
#
#   * <empty>
#     Always matches.
#
#   * <start-of-line>
#     Current parse position is at the start of a line.
#
#   * <end-of-stream>
#     Current parse position is at the end of the input stream.
#
#   * <auto-detect-indent>
#     Detect the number of characters of new indentation.
#
#
#   == Rule Definitions ==
#
# The rule definitions here are expressed as YAML data structures where the
# scalar values can be:
#
#   * A rule name
#   * A literal character (always single quoted for clarity)
#   * Some special DSL forms
#
# The various DSL forms were chosen carefully to be easily read and understood
# by the people reading it. The rest of this section describes those forms.
#
#   === Special Syntax Used ===
#
# There are some syntax conventions used for clarity. Everything is valid YAML.
# Certain things could be expressed in YAML different ways. For instance a
# single character to be matched could be unquoted, single-quoted or
# double-quoted. If the intent is to match a single character, it is single
# quoted.
#
#   * unquoted-word         -- Usually a rule name
#   * unquoted-single-char  -- A variable name
#   * single-quoted-char    -- A character to match
#   * double-quoted-string  -- A literal string value
#   * (...)                 -- A parsing function
#   * <...>                 -- A special rule name
#
#   === Hex Codes ===
#
# Hex codes are scalars beginning with an `x` followed by an even number of
# uppercase hexadecimal digits. Since hex codes represent characters they are
# encoded in single quotes.
#
# There are hex ranges as well, which consist of a pair hex codes.
#
#   === Rule Functions ===
#
# The grammar uses these functions. The function name is always in parentheses.
# The name is a key of a single pair mapping.
#
#   * (any)
#     One of the rules in the group must match.
#
#   * (all)
#     All of the rules in the group must match.
#
#   * (+++)
#     The rule must match 1 or more times.
#
#   * (***)
#     The rule must match 0 or more times.
#
#   * (???)
#     The rule must match 0 or 1 times.
#
#   * ({x})
#     The rule must match x times, where x is an integer or a variable.
#
#   * (===)
#     Positive look-ahead assertion.
#
#   * (!==)
#     Negative look-ahead assertion.
#
#   * (<==)
#     Positive look-behind assertion.
#
#   * (---)
#     A set of characters comprised of the first set minus each of the others.
#
#   * (...)
#     The argument variables that are passed to this rule. Either a single
#     value or a sequence of values.
#
#   * (case)
#     A variable indicated by `var` must match one of the other keys. The value
#     of the matching key pair is the next rule to be checked.
#
#   * (flip)
#     Some grammar rules like 136, don't attempt to match anything. They are
#     functions that change a variable. Rule 136 uses the (flip) function to
#     change a variable from one value to another.
#
#   * (if)
#     Check the rule indicated by the value. If it matches, call the (set)
#     function that must be provided.
#
#   * (set)
#     The value is a 2 element sequence. The first element is a variable and
#     the second is an expression. Set the variable to the value of the
#     evaluated expression.
#
#   * (ord)
#     Convert a character (1-9) to an integer.
#
#   * (match)
#     Return the string or character value of the last rule match.
#
#   * (len)
#     Return the length of a string value.
#
#   * (max)
#     The YAML spec grammar constrains some rules to complete in the next 1024
#     characters. The (max) function is used to indicate that this is the
#     case. How it is implemented (like many things) is left as an exercise for
#     the parser author.
#
#   * (exclude)
#     This one is a doozy. It indicates a rule that must not match during any
#     of the recursive sub-matches. Since it is used near the top of the
#     grammar, it affects almost everything.
#
#   * (+)
#     Return the first argument plus the second.
#
#   * (-)
#     Return the first argument minus the second.
#
#   * (<)
#     First argument is less than the second.
#
#   * (<=)
#     First argument is less than the second.
#
#===============================================================================

### 5.1. Character Set


#===============================================================================
# This is the complete set of characters allowed in a YAML stream.
#
# The (any) means that any one of the value group's rules must match for the
# group to match. The remaining rules are attempted in order.
#
# The rules beginning with `x` are hex codes. The pairs of hex codes are
# character ranges.
#===============================================================================

:001: c-printable
# c-printable ::=
#   x:9 | x:A | x:D | [x:20-x:7E]
#   | x:85 | [x:A0-x:D7FF] | [x:E000-x:FFFD]
#   | [x:10000-x:10FFFF]

c-printable:
  (any):
  - 'x09'
  - 'x0A'
  - 'x0D'
  - [ 'x20', 'x7E' ]
  - 'x85'
  - [ 'xA0', 'xD7FF' ]
  - [ 'xE000', 'xFFFD' ]
  - [ 'x010000', 'x10FFFF' ]



:002: nb-json
# nb-json ::=
#   x:9 | [x:20-x:10FFFF]

nb-json:
  (any):
  - 'x09'
  - [ 'x20', 'x10FFFF' ]



### 5.2. Character Encodings


#===============================================================================
# Rules 003-021 define single characters. These rules are never referenced in
# the rest of the grammar. They should at least be referenced in rule 022.
#===============================================================================

:003: c-byte-order-mark
# c-byte-order-mark ::=
#   x:FEFF

c-byte-order-mark: 'xFEFF'



### 5.3. Indicator Characters


#===============================================================================
# Rules 004 to 021 are single characters to match. Instead of a hex code, they
# are specified as a single character in single quotes.
#===============================================================================

:004: c-sequence-entry
# c-sequence-entry ::=
#   '-'

c-sequence-entry: '-'



:005: c-mapping-key
# c-mapping-key ::=
#   '?'

c-mapping-key: '?'



:006: c-mapping-value
# c-mapping-value ::=
#   ':'

c-mapping-value: ':'



:007: c-collect-entry
# c-collect-entry ::=
#   ','

c-collect-entry: ','



:008: c-sequence-start
# c-sequence-start ::=
#   '['

c-sequence-start: '['



:009: c-sequence-end
# c-sequence-end ::=
#   ']'

c-sequence-end: ']'



:010: c-mapping-start
# c-mapping-start ::=
#   '{'

c-mapping-start: '{'



:011: c-mapping-end
# c-mapping-end ::=
#   '}'

c-mapping-end: '}'



:012: c-comment
# c-comment ::=
#   '#'

c-comment: '#'



:013: c-anchor
# c-anchor ::=
#   '&'

c-anchor: '&'



:014: c-alias
# c-alias ::=
#   '*'

c-alias: '*'



:015: c-tag
# c-tag ::=
#   '!'

c-tag: '!'



:016: c-literal
# c-literal ::=
#   '|'

c-literal: '|'



:017: c-folded
# c-folded ::=
#   '>'

c-folded: '>'



:018: c-single-quote
# c-single-quote ::=
#   '''

c-single-quote: ''''



:019: c-double-quote
# c-double-quote ::=
#   '"'

c-double-quote: '"'



:020: c-directive
# c-directive ::=
#   '%'

c-directive: '%'



:021: c-reserved
# c-reserved ::=
#   '@' | '`'

c-reserved:
  (any):
  - '@'
  - '`'



#===============================================================================
# Rule 022 should probably be defined using the rule names above rather than
# literal characters.
#===============================================================================

:022: c-indicator
# c-indicator ::=
#   '-' | '?' | ':' | ',' | '[' | ']' | '{' | '}'
#   | '#' | '&' | '*' | '!' | '|' | '>' | ''' | '"'
#   | '%' | '@' | '`'

c-indicator:
  (any):
  - '-'
  - '?'
  - ':'
  - ','
  - '['
  - ']'
  - '{'
  - '}'
  - '#'
  - '&'
  - '*'
  - '!'
  - '|'
  - '>'
  - ''''
  - '"'
  - '%'
  - '@'
  - '`'



:023: c-flow-indicator
# c-flow-indicator ::=
#   ',' | '[' | ']' | '{' | '}'

c-flow-indicator:
  (any):
  - ','
  - '['
  - ']'
  - '{'
  - '}'



### 5.4. Line Break Characters


:024: b-line-feed
# b-line-feed ::=
#   x:A

b-line-feed: 'x0A'



:025: b-carriage-return
# b-carriage-return ::=
#   x:D

b-carriage-return: 'x0D'



#===============================================================================
# Rules can "call" other rules by name. This is called a rule reference. A
# reference matches if its named rule matches.
#===============================================================================

:026: b-char
# b-char ::=
#   b-line-feed | b-carriage-return

b-char:
  (any):
  - b-line-feed
  - b-carriage-return



#===============================================================================
# The (---) operator here matches if the next character is in the first range,
# but not in any of the following ranges.
#===============================================================================

:027: nb-char
# nb-char ::=
#   c-printable - b-char - c-byte-order-mark

nb-char:
  (---):
  - c-printable
  - b-char
  - c-byte-order-mark



#===============================================================================
# A rule in in a group of rules can be another group. This is how parenthesized
# groups are represented.
#
# The (all) function matches if all the rules in its group match.
#===============================================================================

:028: b-break
# b-break ::=
#   ( b-carriage-return b-line-feed )
#   | b-carriage-return
#   | b-line-feed

b-break:
  (any):
  - (all):
    - b-carriage-return
    - b-line-feed
  - b-carriage-return
  - b-line-feed



:029: b-as-line-feed
# b-as-line-feed ::=
#   b-break

b-as-line-feed: b-break



:030: b-non-content
# b-non-content ::=
#   b-break

b-non-content: b-break



### 5.5. White Space Characters


:031: s-space
# s-space ::=
#   x:20

s-space: 'x20'



:032: s-tab
# s-tab ::=
#   x:9

s-tab: 'x09'



:033: s-white
# s-white ::=
#   s-space | s-tab

s-white:
  (any):
  - s-space
  - s-tab



:034: ns-char
# ns-char ::=
#   nb-char - s-white

ns-char:
  (---):
  - nb-char
  - s-white



### 5.6. Miscellaneous Characters


:035: ns-dec-digit
# ns-dec-digit ::=
#   [x:30-x:39]

ns-dec-digit: [ 'x30', 'x39' ]



:036: ns-hex-digit
# ns-hex-digit ::=
#   ns-dec-digit
#   | [x:41-x:46] | [x:61-x:66]

ns-hex-digit:
  (any):
  - ns-dec-digit
  - [ 'x41', 'x46' ]
  - [ 'x61', 'x66' ]



:037: ns-ascii-letter
# ns-ascii-letter ::=
#   [x:41-x:5A] | [x:61-x:7A]

ns-ascii-letter:
  (any):
  - [ 'x41', 'x5A' ]
  - [ 'x61', 'x7A' ]



:038: ns-word-char
# ns-word-char ::=
#   ns-dec-digit | ns-ascii-letter | '-'

ns-word-char:
  (any):
  - ns-dec-digit
  - ns-ascii-letter
  - '-'



:039: ns-uri-char
# ns-uri-char ::=
#   '%' ns-hex-digit ns-hex-digit | ns-word-char | '#'
#   | ';' | '/' | '?' | ':' | '@' | '&' | '=' | '+' | '$' | ','
#   | '_' | '.' | '!' | '~' | '*' | ''' | '(' | ')' | '[' | ']'

ns-uri-char:
  (any):
  - (all):
    - '%'
    - ns-hex-digit
    - ns-hex-digit
  - ns-word-char
  - '#'
  - ';'
  - '/'
  - '?'
  - ':'
  - '@'
  - '&'
  - '='
  - '+'
  - '$'
  - ','
  - '_'
  - '.'
  - '!'
  - '~'
  - '*'
  - ''''
  - '('
  - ')'
  - '['
  - ']'



:040: ns-tag-char
# ns-tag-char ::=
#   ns-uri-char - '!' - c-flow-indicator

ns-tag-char:
  (---):
  - ns-uri-char
  - '!'
  - c-flow-indicator



### 5.7. Escaped Characters


:041: c-escape
# c-escape ::=
#   '\'

c-escape: '\'



:042: ns-esc-null
# ns-esc-null ::=
#   '0'

ns-esc-null: '0'



:043: ns-esc-bell
# ns-esc-bell ::=
#   'a'

ns-esc-bell: 'a'



:044: ns-esc-backspace
# ns-esc-backspace ::=
#   'b'

ns-esc-backspace: 'b'



:045: ns-esc-horizontal-tab
# ns-esc-horizontal-tab ::=
#   't' | x:9

ns-esc-horizontal-tab:
  (any):
  - t
  - 'x09'



:046: ns-esc-line-feed
# ns-esc-line-feed ::=
#   'n'

ns-esc-line-feed: 'n'



:047: ns-esc-vertical-tab
# ns-esc-vertical-tab ::=
#   'v'

ns-esc-vertical-tab: 'v'



:048: ns-esc-form-feed
# ns-esc-form-feed ::=
#   'f'

ns-esc-form-feed: 'f'



:049: ns-esc-carriage-return
# ns-esc-carriage-return ::=
#   'r'

ns-esc-carriage-return: 'r'



:050: ns-esc-escape
# ns-esc-escape ::=
#   'e'

ns-esc-escape: 'e'



:051: ns-esc-space
# ns-esc-space ::=
#   x:20

ns-esc-space: 'x20'



:052: ns-esc-double-quote
# ns-esc-double-quote ::=
#   '"'

ns-esc-double-quote: '"'



:053: ns-esc-slash
# ns-esc-slash ::=
#   '/'

ns-esc-slash: '/'



:054: ns-esc-backslash
# ns-esc-backslash ::=
#   '\'

ns-esc-backslash: '\'



:055: ns-esc-next-line
# ns-esc-next-line ::=
#   'N'

ns-esc-next-line: 'N'



:056: ns-esc-non-breaking-space
# ns-esc-non-breaking-space ::=
#   '_'

ns-esc-non-breaking-space: '_'



:057: ns-esc-line-separator
# ns-esc-line-separator ::=
#   'L'

ns-esc-line-separator: 'L'



:058: ns-esc-paragraph-separator
# ns-esc-paragraph-separator ::=
#   'P'

ns-esc-paragraph-separator: 'P'



#===============================================================================
# The ({x}) is a numeric quantifier. ie The rule must match that exact number
# of times.
#===============================================================================

:059: ns-esc-8-bit
# ns-esc-8-bit ::=
#   'x'
#   ( ns-hex-digit{2} )

ns-esc-8-bit:
  (all):
  - 'x'
  - ({2}): ns-hex-digit



:060: ns-esc-16-bit
# ns-esc-16-bit ::=
#   'u'
#   ( ns-hex-digit{4} )

ns-esc-16-bit:
  (all):
  - 'u'
  - ({4}): ns-hex-digit



:061: ns-esc-32-bit
# ns-esc-32-bit ::=
#   'U'
#   ( ns-hex-digit{8} )

ns-esc-32-bit:
  (all):
  - 'U'
  - ({8}): ns-hex-digit



:062: c-ns-esc-char
# c-ns-esc-char ::=
#   '\'
#   ( ns-esc-null | ns-esc-bell | ns-esc-backspace
#   | ns-esc-horizontal-tab | ns-esc-line-feed
#   | ns-esc-vertical-tab | ns-esc-form-feed
#   | ns-esc-carriage-return | ns-esc-escape | ns-esc-space
#   | ns-esc-double-quote | ns-esc-slash | ns-esc-backslash
#   | ns-esc-next-line | ns-esc-non-breaking-space
#   | ns-esc-line-separator | ns-esc-paragraph-separator
#   | ns-esc-8-bit | ns-esc-16-bit | ns-esc-32-bit )

c-ns-esc-char:
  (all):
  - '\'
  - (any):
    - ns-esc-null
    - ns-esc-bell
    - ns-esc-backspace
    - ns-esc-horizontal-tab
    - ns-esc-line-feed
    - ns-esc-vertical-tab
    - ns-esc-form-feed
    - ns-esc-carriage-return
    - ns-esc-escape
    - ns-esc-space
    - ns-esc-double-quote
    - ns-esc-slash
    - ns-esc-backslash
    - ns-esc-next-line
    - ns-esc-non-breaking-space
    - ns-esc-line-separator
    - ns-esc-paragraph-separator
    - ns-esc-8-bit
    - ns-esc-16-bit
    - ns-esc-32-bit



### 6.1. Indentation Spaces


#===============================================================================
# Some rules are intended to be called with arguments. Arguments are specified
# with the (...) key. A single argument is a scalar value. Multiple arguments
# are specified as a sequence.
#===============================================================================

:063: s-indent
# s-indent(n) ::=
#   s-space{n}

s-indent:
  (...): n
  ({n}): s-space



#===============================================================================
# This rule means to match as many spaces as possible, then check the length of
# the match is less than the indentation level in variable n. The (<<<) means
# that if both assertions are not true, backtrack to where the rule started.
#
# The (***) function means the rule must match 0 or more times.
#
# The (<) function matches if the first argument is less than the second.
#
# The (len) function returns the length of a string, and the (match) function
# returns the last match.
#===============================================================================

:064: s-indent-lt
# s-indent(<n) ::=
#   s-space{m} <where_m_<_n>

s-indent-lt:
  (...): n
  (<<<):
    (all):
    - (***): s-space
    - (<): [ { (len): (match) }, n ]



#===============================================================================
# The (<=) function matches if the first argument is less or equal to the
# second.
#===============================================================================

:065: s-indent-le
# s-indent(<=n) ::=
#   s-space{m} <where_m_<=_n>

s-indent-le:
  (...): n
  (<<<):
    (all):
    - (***): s-space
    - (<=): [ { (len): (match) }, n ]



### 6.2. Separation Spaces


#===============================================================================
# The (+++) function means the rule must match 1 or more times.
#
# The <start-of-line> rule is a "special" rule. It's not defined in the
# grammar. It's an assertion that the current parse position is on a "start of
# line" boundary.
#===============================================================================

:066: s-separate-in-line
# s-separate-in-line ::=
#   s-white+ | <start_of_line>

s-separate-in-line:
  (any):
  - (+++): s-white
  - <start-of-line>



### 6.3. Line Prefixes


#===============================================================================
# A (case) statement is a mapping that chooses the next rule based on the value
# of a state variable (in this case `c`).
#
# 7 rules in this grammar have (case) statements.
#===============================================================================

:067: s-line-prefix
# s-line-prefix(n,c) ::=
#   ( c = block-out => s-block-line-prefix(n) )
#   ( c = block-in => s-block-line-prefix(n) )
#   ( c = flow-out => s-flow-line-prefix(n) )
#   ( c = flow-in => s-flow-line-prefix(n) )

s-line-prefix:
  (...): [ n, c ]
  (case):
    var: c
    "block-in": { s-block-line-prefix: n }
    "block-out": { s-block-line-prefix: n }
    "flow-in": { s-flow-line-prefix: n }
    "flow-out": { s-flow-line-prefix: n }



:068: s-block-line-prefix
# s-block-line-prefix(n) ::=
#   s-indent(n)

s-block-line-prefix:
  (...): n
  s-indent: n



#===============================================================================
# The (???) function means the rule must match 0 or 1 times.
#===============================================================================

:069: s-flow-line-prefix
# s-flow-line-prefix(n) ::=
#   s-indent(n)
#   s-separate-in-line?

s-flow-line-prefix:
  (...): n
  (all):
  - s-indent: n
  - (???): s-separate-in-line



### 6.4. Empty Lines


:070: l-empty
# l-empty(n,c) ::=
#   ( s-line-prefix(n,c) | s-indent(<n) )
#   b-as-line-feed

l-empty:
  (...): [ n, c ]
  (all):
  - (any):
    - s-line-prefix: [ n, c ]
    - s-indent-lt: n
  - b-as-line-feed



### 6.5. Line Folding


:071: b-l-trimmed
# b-l-trimmed(n,c) ::=
#   b-non-content l-empty(n,c)+

b-l-trimmed:
  (...): [ n, c ]
  (all):
  - b-non-content
  - (+++): { l-empty: [ n, c ] }



:072: b-as-space
# b-as-space ::=
#   b-break

b-as-space: b-break



:073: b-l-folded
# b-l-folded(n,c) ::=
#   b-l-trimmed(n,c) | b-as-space

b-l-folded:
  (...): [ n, c ]
  (any):
  - b-l-trimmed: [ n, c ]
  - b-as-space



:074: s-flow-folded
# s-flow-folded(n) ::=
#   s-separate-in-line?
#   b-l-folded(n,flow-in)
#   s-flow-line-prefix(n)

s-flow-folded:
  (...): n
  (all):
  - (???): s-separate-in-line
  - b-l-folded: [ n, "flow-in" ]
  - s-flow-line-prefix: n



### 6.6. Comments


:075: c-nb-comment-text
# c-nb-comment-text ::=
#   '#' nb-char*

c-nb-comment-text:
  (all):
  - '#'
  - (***): nb-char



#===============================================================================
# The <end-of-stream> rule is a "special" rule that matches when there is no
# more text to parse.
#===============================================================================

:076: b-comment
# b-comment ::=
#   b-non-content | <end_of_file>

b-comment:
  (any):
  - b-non-content
  - <end-of-stream>



:077: s-b-comment
# s-b-comment ::=
#   ( s-separate-in-line
#   c-nb-comment-text? )?
#   b-comment

s-b-comment:
  (all):
  - (???):
      (all):
      - s-separate-in-line
      - (???): c-nb-comment-text
  - b-comment



:078: l-comment
# l-comment ::=
#   s-separate-in-line c-nb-comment-text?
#   b-comment

l-comment:
  (all):
  - s-separate-in-line
  - (???): c-nb-comment-text
  - b-comment



:079: s-l-comments
# s-l-comments ::=
#   ( s-b-comment | <start_of_line> )
#   l-comment*

s-l-comments:
  (all):
  - (any):
    - s-b-comment
    - <start-of-line>
  - (***): l-comment



### 6.7. Separation Lines


:080: s-separate
# s-separate(n,c) ::=
#   ( c = block-out => s-separate-lines(n) )
#   ( c = block-in => s-separate-lines(n) )
#   ( c = flow-out => s-separate-lines(n) )
#   ( c = flow-in => s-separate-lines(n) )
#   ( c = block-key => s-separate-in-line )
#   ( c = flow-key => s-separate-in-line )

s-separate:
  (...): [ n, c ]
  (case):
    var: c
    "block-in": { s-separate-lines: n }
    "block-key": s-separate-in-line
    "block-out": { s-separate-lines: n }
    "flow-in": { s-separate-lines: n }
    "flow-key": s-separate-in-line
    "flow-out": { s-separate-lines: n }



:081: s-separate-lines
# s-separate-lines(n) ::=
#   ( s-l-comments
#   s-flow-line-prefix(n) )
#   | s-separate-in-line

s-separate-lines:
  (...): n
  (any):
  - (all):
    - s-l-comments
    - s-flow-line-prefix: n
  - s-separate-in-line



### 6.8. Directives


:082: l-directive
# l-directive ::=
#   '%'
#   ( ns-yaml-directive
#   | ns-tag-directive
#   | ns-reserved-directive )
#   s-l-comments

l-directive:
  (all):
  - '%'
  - (any):
    - ns-yaml-directive
    - ns-tag-directive
    - ns-reserved-directive
  - s-l-comments



:083: ns-reserved-directive
# ns-reserved-directive ::=
#   ns-directive-name
#   ( s-separate-in-line ns-directive-parameter )*

ns-reserved-directive:
  (all):
  - ns-directive-name
  - (***):
      (all):
      - s-separate-in-line
      - ns-directive-parameter



:084: ns-directive-name
# ns-directive-name ::=
#   ns-char+

ns-directive-name: { (+++): ns-char }



:085: ns-directive-parameter
# ns-directive-parameter ::=
#   ns-char+

ns-directive-parameter: { (+++): ns-char }



##### 6.8.1. “YAML” Directives


:086: ns-yaml-directive
# ns-yaml-directive ::=
#   'Y' 'A' 'M' 'L'
#   s-separate-in-line ns-yaml-version

ns-yaml-directive:
  (all):
  - 'Y'
  - 'A'
  - 'M'
  - 'L'
  - s-separate-in-line
  - ns-yaml-version



:087: ns-yaml-version
# ns-yaml-version ::=
#   ns-dec-digit+ '.' ns-dec-digit+

ns-yaml-version:
  (all):
  - (+++): ns-dec-digit
  - '.'
  - (+++): ns-dec-digit



##### 6.8.2. “TAG” Directives


:088: ns-tag-directive
# ns-tag-directive ::=
#   'T' 'A' 'G'
#   s-separate-in-line c-tag-handle
#   s-separate-in-line ns-tag-prefix

ns-tag-directive:
  (all):
  - 'T'
  - 'A'
  - 'G'
  - s-separate-in-line
  - c-tag-handle
  - s-separate-in-line
  - ns-tag-prefix



:089: c-tag-handle
# c-tag-handle ::=
#   c-named-tag-handle
#   | c-secondary-tag-handle
#   | c-primary-tag-handle

c-tag-handle:
  (any):
  - c-named-tag-handle
  - c-secondary-tag-handle
  - c-primary-tag-handle



:090: c-primary-tag-handle
# c-primary-tag-handle ::=
#   '!'

c-primary-tag-handle: '!'



:091: c-secondary-tag-handle
# c-secondary-tag-handle ::=
#   '!' '!'

c-secondary-tag-handle:
  (all):
  - '!'
  - '!'



:092: c-named-tag-handle
# c-named-tag-handle ::=
#   '!' ns-word-char+ '!'

c-named-tag-handle:
  (all):
  - '!'
  - (+++): ns-word-char
  - '!'



:093: ns-tag-prefix
# ns-tag-prefix ::=
#   c-ns-local-tag-prefix | ns-global-tag-prefix

ns-tag-prefix:
  (any):
  - c-ns-local-tag-prefix
  - ns-global-tag-prefix



:094: c-ns-local-tag-prefix
# c-ns-local-tag-prefix ::=
#   '!' ns-uri-char*

c-ns-local-tag-prefix:
  (all):
  - '!'
  - (***): ns-uri-char



:095: ns-global-tag-prefix
# ns-global-tag-prefix ::=
#   ns-tag-char ns-uri-char*

ns-global-tag-prefix:
  (all):
  - ns-tag-char
  - (***): ns-uri-char



### 6.9. Node Properties


:096: c-ns-properties
# c-ns-properties(n,c) ::=
#   ( c-ns-tag-property
#   ( s-separate(n,c) c-ns-anchor-property )? )
#   | ( c-ns-anchor-property
#   ( s-separate(n,c) c-ns-tag-property )? )

c-ns-properties:
  (...): [ n, c ]
  (any):
  - (all):
    - c-ns-tag-property
    - (???):
        (all):
        - s-separate: [ n, c ]
        - c-ns-anchor-property
  - (all):
    - c-ns-anchor-property
    - (???):
        (all):
        - s-separate: [ n, c ]
        - c-ns-tag-property



##### 6.9.1. Node Tags


:097: c-ns-tag-property
# c-ns-tag-property ::=
#   c-verbatim-tag
#   | c-ns-shorthand-tag
#   | c-non-specific-tag

c-ns-tag-property:
  (any):
  - c-verbatim-tag
  - c-ns-shorthand-tag
  - c-non-specific-tag



:098: c-verbatim-tag
# c-verbatim-tag ::=
#   '!' '<' ns-uri-char+ '>'

c-verbatim-tag:
  (all):
  - '!'
  - '<'
  - (+++): ns-uri-char
  - '>'



:099: c-ns-shorthand-tag
# c-ns-shorthand-tag ::=
#   c-tag-handle ns-tag-char+

c-ns-shorthand-tag:
  (all):
  - c-tag-handle
  - (+++): ns-tag-char



:100: c-non-specific-tag
# c-non-specific-tag ::=
#   '!'

c-non-specific-tag: '!'



##### 6.9.2. Node Anchors


:101: c-ns-anchor-property
# c-ns-anchor-property ::=
#   '&' ns-anchor-name

c-ns-anchor-property:
  (all):
  - '&'
  - ns-anchor-name



:102: ns-anchor-char
# ns-anchor-char ::=
#   ns-char - c-flow-indicator

ns-anchor-char:
  (---):
  - ns-char
  - c-flow-indicator



:103: ns-anchor-name
# ns-anchor-name ::=
#   ns-anchor-char+

ns-anchor-name: { (+++): ns-anchor-char }



### 7.1. Alias Nodes


:104: c-ns-alias-node
# c-ns-alias-node ::=
#   '*' ns-anchor-name

c-ns-alias-node:
  (all):
  - '*'
  - ns-anchor-name



### 7.2. Empty Nodes


#===============================================================================
# The <empty> rule is a "special" rule that always matches (but consumes no
# text). It is used to for places in YAML that allow the absence of text to
# represent an empty plain scalar.
#===============================================================================

:105: e-scalar
# e-scalar ::=
#   <empty>

e-scalar: <empty>



:106: e-node
# e-node ::=
#   e-scalar

e-node: e-scalar



### 7.3. Flow Scalar Styles


##### 7.3.1. Double-Quoted Style


:107: nb-double-char
# nb-double-char ::=
#   c-ns-esc-char | ( nb-json - '\' - '"' )

nb-double-char:
  (any):
  - c-ns-esc-char
  - (---):
    - nb-json
    - '\'
    - '"'



:108: ns-double-char
# ns-double-char ::=
#   nb-double-char - s-white

ns-double-char:
  (---):
  - nb-double-char
  - s-white



:109: c-double-quoted
# c-double-quoted(n,c) ::=
#   '"' nb-double-text(n,c)
#   '"'

c-double-quoted:
  (...): [ n, c ]
  (all):
  - '"'
  - nb-double-text: [ n, c ]
  - '"'



:110: nb-double-text
# nb-double-text(n,c) ::=
#   ( c = flow-out => nb-double-multi-line(n) )
#   ( c = flow-in => nb-double-multi-line(n) )
#   ( c = block-key => nb-double-one-line )
#   ( c = flow-key => nb-double-one-line )

nb-double-text:
  (...): [ n, c ]
  (case):
    var: c
    "block-key": nb-double-one-line
    "flow-in": { nb-double-multi-line: n }
    "flow-key": nb-double-one-line
    "flow-out": { nb-double-multi-line: n }



:111: nb-double-one-line
# nb-double-one-line ::=
#   nb-double-char*

nb-double-one-line: { (***): nb-double-char }



:112: s-double-escaped
# s-double-escaped(n) ::=
#   s-white* '\'
#   b-non-content
#   l-empty(n,flow-in)* s-flow-line-prefix(n)

s-double-escaped:
  (...): n
  (all):
  - (***): s-white
  - '\'
  - b-non-content
  - (***): { l-empty: [ n, "flow-in" ] }
  - s-flow-line-prefix: n



:113: s-double-break
# s-double-break(n) ::=
#   s-double-escaped(n) | s-flow-folded(n)

s-double-break:
  (...): n
  (any):
  - s-double-escaped: n
  - s-flow-folded: n



:114: nb-ns-double-in-line
# nb-ns-double-in-line ::=
#   ( s-white* ns-double-char )*

nb-ns-double-in-line:
  (***):
    (all):
    - (***): s-white
    - ns-double-char



:115: s-double-next-line
# s-double-next-line(n) ::=
#   s-double-break(n)
#   ( ns-double-char nb-ns-double-in-line
#   ( s-double-next-line(n) | s-white* ) )?

s-double-next-line:
  (...): n
  (all):
  - s-double-break: n
  - (???):
      (all):
      - ns-double-char
      - nb-ns-double-in-line
      - (any):
        - s-double-next-line: n
        - (***): s-white



:116: nb-double-multi-line
# nb-double-multi-line(n) ::=
#   nb-ns-double-in-line
#   ( s-double-next-line(n) | s-white* )

nb-double-multi-line:
  (...): n
  (all):
  - nb-ns-double-in-line
  - (any):
    - s-double-next-line: n
    - (***): s-white



##### 7.3.2. Single-Quoted Style


:117: c-quoted-quote
# c-quoted-quote ::=
#   ''' '''

c-quoted-quote:
  (all):
  - ''''
  - ''''



:118: nb-single-char
# nb-single-char ::=
#   c-quoted-quote | ( nb-json - ''' )

nb-single-char:
  (any):
  - c-quoted-quote
  - (---):
    - nb-json
    - ''''



:119: ns-single-char
# ns-single-char ::=
#   nb-single-char - s-white

ns-single-char:
  (---):
  - nb-single-char
  - s-white



:120: c-single-quoted
# c-single-quoted(n,c) ::=
#   ''' nb-single-text(n,c)
#   '''

c-single-quoted:
  (...): [ n, c ]
  (all):
  - ''''
  - nb-single-text: [ n, c ]
  - ''''



:121: nb-single-text
# nb-single-text(n,c) ::=
#   ( c = flow-out => nb-single-multi-line(n) )
#   ( c = flow-in => nb-single-multi-line(n) )
#   ( c = block-key => nb-single-one-line )
#   ( c = flow-key => nb-single-one-line )

nb-single-text:
  (...): [ n, c ]
  (case):
    var: c
    "block-key": nb-single-one-line
    "flow-in": { nb-single-multi-line: n }
    "flow-key": nb-single-one-line
    "flow-out": { nb-single-multi-line: n }



:122: nb-single-one-line
# nb-single-one-line ::=
#   nb-single-char*

nb-single-one-line: { (***): nb-single-char }



:123: nb-ns-single-in-line
# nb-ns-single-in-line ::=
#   ( s-white* ns-single-char )*

nb-ns-single-in-line:
  (***):
    (all):
    - (***): s-white
    - ns-single-char



:124: s-single-next-line
# s-single-next-line(n) ::=
#   s-flow-folded(n)
#   ( ns-single-char nb-ns-single-in-line
#   ( s-single-next-line(n) | s-white* ) )?

s-single-next-line:
  (...): n
  (all):
  - s-flow-folded: n
  - (???):
      (all):
      - ns-single-char
      - nb-ns-single-in-line
      - (any):
        - s-single-next-line: n
        - (***): s-white



:125: nb-single-multi-line
# nb-single-multi-line(n) ::=
#   nb-ns-single-in-line
#   ( s-single-next-line(n) | s-white* )

nb-single-multi-line:
  (...): n
  (all):
  - nb-ns-single-in-line
  - (any):
    - s-single-next-line: n
    - (***): s-white



##### 7.3.3. Plain Style


#===============================================================================
# The (===) function is a positive lookahead. It checks to see if a character
# is next, but doesn't consume it.
#===============================================================================

:126: ns-plain-first
# ns-plain-first(c) ::=
#   ( ns-char - c-indicator )
#   | ( ( '?' | ':' | '-' )
#   <followed_by_an_ns-plain-safe(c)> )

ns-plain-first:
  (...): c
  (any):
  - (---):
    - ns-char
    - c-indicator
  - (all):
    - (any):
      - '?'
      - ':'
      - '-'
    - (===): { ns-plain-safe: c }



:127: ns-plain-safe
# ns-plain-safe(c) ::=
#   ( c = flow-out => ns-plain-safe-out )
#   ( c = flow-in => ns-plain-safe-in )
#   ( c = block-key => ns-plain-safe-out )
#   ( c = flow-key => ns-plain-safe-in )

ns-plain-safe:
  (...): c
  (case):
    var: c
    "block-key": ns-plain-safe-out
    "flow-in": ns-plain-safe-in
    "flow-key": ns-plain-safe-in
    "flow-out": ns-plain-safe-out



:128: ns-plain-safe-out
# ns-plain-safe-out ::=
#   ns-char

ns-plain-safe-out: ns-char



:129: ns-plain-safe-in
# ns-plain-safe-in ::=
#   ns-char - c-flow-indicator

ns-plain-safe-in:
  (---):
  - ns-char
  - c-flow-indicator



:130: ns-plain-char
# ns-plain-char(c) ::=
#   ( ns-plain-safe(c) - ':' - '#' )
#   | ( <an_ns-char_preceding> '#' )
#   | ( ':' <followed_by_an_ns-plain-safe(c)> )

ns-plain-char:
  (...): c
  (any):
  - (---):
    - ns-plain-safe: c
    - ':'
    - '#'
  - (all):
    - (<==): ns-char
    - '#'
  - (all):
    - ':'
    - (===): { ns-plain-safe: c }



:131: ns-plain
# ns-plain(n,c) ::=
#   ( c = flow-out => ns-plain-multi-line(n,c) )
#   ( c = flow-in => ns-plain-multi-line(n,c) )
#   ( c = block-key => ns-plain-one-line(c) )
#   ( c = flow-key => ns-plain-one-line(c) )

ns-plain:
  (...): [ n, c ]
  (case):
    var: c
    "block-key": { ns-plain-one-line: c }
    "flow-in": { ns-plain-multi-line: [ n, c ] }
    "flow-key": { ns-plain-one-line: c }
    "flow-out": { ns-plain-multi-line: [ n, c ] }



:132: nb-ns-plain-in-line
# nb-ns-plain-in-line(c) ::=
#   ( s-white*
#   ns-plain-char(c) )*

nb-ns-plain-in-line:
  (...): c
  (***):
    (all):
    - (***): s-white
    - ns-plain-char: c



:133: ns-plain-one-line
# ns-plain-one-line(c) ::=
#   ns-plain-first(c)
#   nb-ns-plain-in-line(c)

ns-plain-one-line:
  (...): c
  (all):
  - ns-plain-first: c
  - nb-ns-plain-in-line: c



:134: s-ns-plain-next-line
# s-ns-plain-next-line(n,c) ::=
#   s-flow-folded(n)
#   ns-plain-char(c) nb-ns-plain-in-line(c)

s-ns-plain-next-line:
  (...): [ n, c ]
  (all):
  - s-flow-folded: n
  - ns-plain-char: c
  - nb-ns-plain-in-line: c



:135: ns-plain-multi-line
# ns-plain-multi-line(n,c) ::=
#   ns-plain-one-line(c)
#   s-ns-plain-next-line(n,c)*

ns-plain-multi-line:
  (...): [ n, c ]
  (all):
  - ns-plain-one-line: c
  - (***): { s-ns-plain-next-line: [ n, c ] }



### 7.4. Flow Collection Styles


#===============================================================================
# The (flip) function uses a mapping to change an input value to another value,
# and returns the new value.
#===============================================================================

:136: in-flow
# in-flow(c) ::=
#   ( c = flow-out => flow-in )
#   ( c = flow-in => flow-in )
#   ( c = block-key => flow-key )
#   ( c = flow-key => flow-key )

in-flow:
  (...): c
  (flip):
    var: c
    "block-key": "flow-key"
    "flow-in": "flow-in"
    "flow-key": "flow-key"
    "flow-out": "flow-in"



##### 7.4.1. Flow Sequences


:137: c-flow-sequence
# c-flow-sequence(n,c) ::=
#   '[' s-separate(n,c)?
#   ns-s-flow-seq-entries(n,in-flow(c))? ']'

c-flow-sequence:
  (...): [ n, c ]
  (all):
  - '['
  - (???): { s-separate: [ n, c ] }
  - (???): { ns-s-flow-seq-entries: [ n, { in-flow: c } ] }
  - ']'



:138: ns-s-flow-seq-entries
# ns-s-flow-seq-entries(n,c) ::=
#   ns-flow-seq-entry(n,c)
#   s-separate(n,c)?
#   ( ',' s-separate(n,c)?
#   ns-s-flow-seq-entries(n,c)? )?

ns-s-flow-seq-entries:
  (...): [ n, c ]
  (all):
  - ns-flow-seq-entry: [ n, c ]
  - (???): { s-separate: [ n, c ] }
  - (???):
      (all):
      - ','
      - (???): { s-separate: [ n, c ] }
      - (???): { ns-s-flow-seq-entries: [ n, c ] }



:139: ns-flow-seq-entry
# ns-flow-seq-entry(n,c) ::=
#   ns-flow-pair(n,c) | ns-flow-node(n,c)

ns-flow-seq-entry:
  (...): [ n, c ]
  (any):
  - ns-flow-pair: [ n, c ]
  - ns-flow-node: [ n, c ]



##### 7.4.2. Flow Mappings


:140: c-flow-mapping
# c-flow-mapping(n,c) ::=
#   '{' s-separate(n,c)?
#   ns-s-flow-map-entries(n,in-flow(c))? '}'

c-flow-mapping:
  (...): [ n, c ]
  (all):
  - '{'
  - (???): { s-separate: [ n, c ] }
  - (???): { ns-s-flow-map-entries: [ n, { in-flow: c } ] }
  - '}'



:141: ns-s-flow-map-entries
# ns-s-flow-map-entries(n,c) ::=
#   ns-flow-map-entry(n,c)
#   s-separate(n,c)?
#   ( ',' s-separate(n,c)?
#   ns-s-flow-map-entries(n,c)? )?

ns-s-flow-map-entries:
  (...): [ n, c ]
  (all):
  - ns-flow-map-entry: [ n, c ]
  - (???): { s-separate: [ n, c ] }
  - (???):
      (all):
      - ','
      - (???): { s-separate: [ n, c ] }
      - (???): { ns-s-flow-map-entries: [ n, c ] }



:142: ns-flow-map-entry
# ns-flow-map-entry(n,c) ::=
#   ( '?' s-separate(n,c)
#   ns-flow-map-explicit-entry(n,c) )
#   | ns-flow-map-implicit-entry(n,c)

ns-flow-map-entry:
  (...): [ n, c ]
  (any):
  - (all):
    - '?'
    - s-separate: [ n, c ]
    - ns-flow-map-explicit-entry: [ n, c ]
  - ns-flow-map-implicit-entry: [ n, c ]



:143: ns-flow-map-explicit-entry
# ns-flow-map-explicit-entry(n,c) ::=
#   ns-flow-map-implicit-entry(n,c)
#   | ( e-node
#   e-node )

ns-flow-map-explicit-entry:
  (...): [ n, c ]
  (any):
  - ns-flow-map-implicit-entry: [ n, c ]
  - (all):
    - e-node
    - e-node



:144: ns-flow-map-implicit-entry
# ns-flow-map-implicit-entry(n,c) ::=
#   ns-flow-map-yaml-key-entry(n,c)
#   | c-ns-flow-map-empty-key-entry(n,c)
#   | c-ns-flow-map-json-key-entry(n,c)

ns-flow-map-implicit-entry:
  (...): [ n, c ]
  (any):
  - ns-flow-map-yaml-key-entry: [ n, c ]
  - c-ns-flow-map-empty-key-entry: [ n, c ]
  - c-ns-flow-map-json-key-entry: [ n, c ]



:145: ns-flow-map-yaml-key-entry
# ns-flow-map-yaml-key-entry(n,c) ::=
#   ns-flow-yaml-node(n,c)
#   ( ( s-separate(n,c)?
#   c-ns-flow-map-separate-value(n,c) )
#   | e-node )

ns-flow-map-yaml-key-entry:
  (...): [ n, c ]
  (all):
  - ns-flow-yaml-node: [ n, c ]
  - (any):
    - (all):
      - (???): { s-separate: [ n, c ] }
      - c-ns-flow-map-separate-value: [ n, c ]
    - e-node



:146: c-ns-flow-map-empty-key-entry
# c-ns-flow-map-empty-key-entry(n,c) ::=
#   e-node
#   c-ns-flow-map-separate-value(n,c)

c-ns-flow-map-empty-key-entry:
  (...): [ n, c ]
  (all):
  - e-node
  - c-ns-flow-map-separate-value: [ n, c ]



:147: c-ns-flow-map-separate-value
# c-ns-flow-map-separate-value(n,c) ::=
#   ':' <not_followed_by_an_ns-plain-safe(c)>
#   ( ( s-separate(n,c) ns-flow-node(n,c) )
#   | e-node )

c-ns-flow-map-separate-value:
  (...): [ n, c ]
  (all):
  - ':'
  - (!==): { ns-plain-safe: c }
  - (any):
    - (all):
      - s-separate: [ n, c ]
      - ns-flow-node: [ n, c ]
    - e-node



:148: c-ns-flow-map-json-key-entry
# c-ns-flow-map-json-key-entry(n,c) ::=
#   c-flow-json-node(n,c)
#   ( ( s-separate(n,c)?
#   c-ns-flow-map-adjacent-value(n,c) )
#   | e-node )

c-ns-flow-map-json-key-entry:
  (...): [ n, c ]
  (all):
  - c-flow-json-node: [ n, c ]
  - (any):
    - (all):
      - (???): { s-separate: [ n, c ] }
      - c-ns-flow-map-adjacent-value: [ n, c ]
    - e-node



:149: c-ns-flow-map-adjacent-value
# c-ns-flow-map-adjacent-value(n,c) ::=
#   ':' ( (
#   s-separate(n,c)?
#   ns-flow-node(n,c) )
#   | e-node )

c-ns-flow-map-adjacent-value:
  (...): [ n, c ]
  (all):
  - ':'
  - (any):
    - (all):
      - (???): { s-separate: [ n, c ] }
      - ns-flow-node: [ n, c ]
    - e-node



:150: ns-flow-pair
# ns-flow-pair(n,c) ::=
#   ( '?' s-separate(n,c)
#   ns-flow-map-explicit-entry(n,c) )
#   | ns-flow-pair-entry(n,c)

ns-flow-pair:
  (...): [ n, c ]
  (any):
  - (all):
    - '?'
    - s-separate: [ n, c ]
    - ns-flow-map-explicit-entry: [ n, c ]
  - ns-flow-pair-entry: [ n, c ]



:151: ns-flow-pair-entry
# ns-flow-pair-entry(n,c) ::=
#   ns-flow-pair-yaml-key-entry(n,c)
#   | c-ns-flow-map-empty-key-entry(n,c)
#   | c-ns-flow-pair-json-key-entry(n,c)

ns-flow-pair-entry:
  (...): [ n, c ]
  (any):
  - ns-flow-pair-yaml-key-entry: [ n, c ]
  - c-ns-flow-map-empty-key-entry: [ n, c ]
  - c-ns-flow-pair-json-key-entry: [ n, c ]



:152: ns-flow-pair-yaml-key-entry
# ns-flow-pair-yaml-key-entry(n,c) ::=
#   ns-s-implicit-yaml-key(flow-key)
#   c-ns-flow-map-separate-value(n,c)

ns-flow-pair-yaml-key-entry:
  (...): [ n, c ]
  (all):
  - ns-s-implicit-yaml-key: "flow-key"
  - c-ns-flow-map-separate-value: [ n, c ]



:153: c-ns-flow-pair-json-key-entry
# c-ns-flow-pair-json-key-entry(n,c) ::=
#   c-s-implicit-json-key(flow-key)
#   c-ns-flow-map-adjacent-value(n,c)

c-ns-flow-pair-json-key-entry:
  (...): [ n, c ]
  (all):
  - c-s-implicit-json-key: "flow-key"
  - c-ns-flow-map-adjacent-value: [ n, c ]



#===============================================================================
# The (max) function tells the parser that it can consider only the given
# number of characters to match the next rule.
#===============================================================================

:154: ns-s-implicit-yaml-key
# ns-s-implicit-yaml-key(c) ::=
#   ns-flow-yaml-node(n/a,c)
#   s-separate-in-line?
#   <at_most_1024_characters_altogether>

ns-s-implicit-yaml-key:
  (...): c
  (all):
  - (max): 1024
  - ns-flow-yaml-node: [ null, c ]
  - (???): s-separate-in-line



:155: c-s-implicit-json-key
# c-s-implicit-json-key(c) ::=
#   c-flow-json-node(n/a,c)
#   s-separate-in-line?
#   <at_most_1024_characters_altogether>

c-s-implicit-json-key:
  (...): c
  (all):
  - (max): 1024
  - c-flow-json-node: [ null, c ]
  - (???): s-separate-in-line



### 7.5. Flow Nodes


:156: ns-flow-yaml-content
# ns-flow-yaml-content(n,c) ::=
#   ns-plain(n,c)

ns-flow-yaml-content:
  (...): [ n, c ]
  ns-plain: [ n, c ]



:157: c-flow-json-content
# c-flow-json-content(n,c) ::=
#   c-flow-sequence(n,c) | c-flow-mapping(n,c)
#   | c-single-quoted(n,c) | c-double-quoted(n,c)

c-flow-json-content:
  (...): [ n, c ]
  (any):
  - c-flow-sequence: [ n, c ]
  - c-flow-mapping: [ n, c ]
  - c-single-quoted: [ n, c ]
  - c-double-quoted: [ n, c ]



:158: ns-flow-content
# ns-flow-content(n,c) ::=
#   ns-flow-yaml-content(n,c) | c-flow-json-content(n,c)

ns-flow-content:
  (...): [ n, c ]
  (any):
  - ns-flow-yaml-content: [ n, c ]
  - c-flow-json-content: [ n, c ]



:159: ns-flow-yaml-node
# ns-flow-yaml-node(n,c) ::=
#   c-ns-alias-node
#   | ns-flow-yaml-content(n,c)
#   | ( c-ns-properties(n,c)
#   ( ( s-separate(n,c)
#   ns-flow-yaml-content(n,c) )
#   | e-scalar ) )

ns-flow-yaml-node:
  (...): [ n, c ]
  (any):
  - c-ns-alias-node
  - ns-flow-yaml-content: [ n, c ]
  - (all):
    - c-ns-properties: [ n, c ]
    - (any):
      - (all):
        - s-separate: [ n, c ]
        - ns-flow-yaml-content: [ n, c ]
      - e-scalar



:160: c-flow-json-node
# c-flow-json-node(n,c) ::=
#   ( c-ns-properties(n,c)
#   s-separate(n,c) )?
#   c-flow-json-content(n,c)

c-flow-json-node:
  (...): [ n, c ]
  (all):
  - (???):
      (all):
      - c-ns-properties: [ n, c ]
      - s-separate: [ n, c ]
  - c-flow-json-content: [ n, c ]



:161: ns-flow-node
# ns-flow-node(n,c) ::=
#   c-ns-alias-node
#   | ns-flow-content(n,c)
#   | ( c-ns-properties(n,c)
#   ( ( s-separate(n,c)
#   ns-flow-content(n,c) )
#   | e-scalar ) )

ns-flow-node:
  (...): [ n, c ]
  (any):
  - c-ns-alias-node
  - ns-flow-content: [ n, c ]
  - (all):
    - c-ns-properties: [ n, c ]
    - (any):
      - (all):
        - s-separate: [ n, c ]
        - ns-flow-content: [ n, c ]
      - e-scalar



### 8.1. Block Scalar Styles


##### 8.1.1. Block Scalar Headers


:162: c-b-block-header
# c-b-block-header(m,t) ::=
#   ( ( c-indentation-indicator(m)
#   c-chomping-indicator(t) )
#   | ( c-chomping-indicator(t)
#   c-indentation-indicator(m) ) )
#   s-b-comment

c-b-block-header:
  (...): [ m, t ]
  (all):
  - (any):
    - (all):
      - c-indentation-indicator: m
      - c-chomping-indicator: t
    - (all):
      - c-chomping-indicator: t
      - c-indentation-indicator: m
  - s-b-comment



:163: c-indentation-indicator
# c-indentation-indicator(m) ::=
#   ( ns-dec-digit => m = ns-dec-digit - x:30 )
#   ( <empty> => m = auto-detect() )

c-indentation-indicator:
  (...): m
  (any):
  - (if): ns-dec-digit
    (set): [ m, { (ord): (match) } ]
  - (if): <empty>
    (set): [ m, "auto-detect" ]



:164: c-chomping-indicator
# c-chomping-indicator(t) ::=
#   ( '-' => t = strip )
#   ( '+' => t = keep )
#   ( <empty> => t = clip )

c-chomping-indicator:
  (...): t
  (any):
  - (if): '-'
    (set): [ t, "strip" ]
  - (if): '+'
    (set): [ t, "keep" ]
  - (if): <empty>
    (set): [ t, "clip" ]



:165: b-chomped-last
# b-chomped-last(t) ::=
#   ( t = strip => b-non-content | <end_of_file> )
#   ( t = clip => b-as-line-feed | <end_of_file> )
#   ( t = keep => b-as-line-feed | <end_of_file> )

b-chomped-last:
  (...): t
  (case):
    var: t
    "clip": { (any): [ b-as-line-feed, <end-of-stream> ] }
    "keep": { (any): [ b-as-line-feed, <end-of-stream> ] }
    "strip": { (any): [ b-non-content, <end-of-stream> ] }



:166: l-chomped-empty
# l-chomped-empty(n,t) ::=
#   ( t = strip => l-strip-empty(n) )
#   ( t = clip => l-strip-empty(n) )
#   ( t = keep => l-keep-empty(n) )

l-chomped-empty:
  (...): [ n, t ]
  (case):
    var: t
    "clip": { l-strip-empty: n }
    "keep": { l-keep-empty: n }
    "strip": { l-strip-empty: n }



:167: l-strip-empty
# l-strip-empty(n) ::=
#   ( s-indent(<=n) b-non-content )*
#   l-trail-comments(n)?

l-strip-empty:
  (...): n
  (all):
  - (***):
      (all):
      - s-indent-le: n
      - b-non-content
  - (???): { l-trail-comments: n }



:168: l-keep-empty
# l-keep-empty(n) ::=
#   l-empty(n,block-in)*
#   l-trail-comments(n)?

l-keep-empty:
  (...): n
  (all):
  - (***): { l-empty: [ n, "block-in" ] }
  - (???): { l-trail-comments: n }



:169: l-trail-comments
# l-trail-comments(n) ::=
#   s-indent(<n)
#   c-nb-comment-text b-comment
#   l-comment*

l-trail-comments:
  (...): n
  (all):
  - s-indent-lt: n
  - c-nb-comment-text
  - b-comment
  - (***): l-comment



##### 8.1.2. Literal Style


:170: c-l+literal
# c-l+literal(n) ::=
#   '|' c-b-block-header(m,t)
#   l-literal-content(n+m,t)

c-l+literal:
  (...): n
  (all):
  - '|'
  - c-b-block-header: [ m, t ]
  - l-literal-content: [ { (+): [ n, m ] }, t ]



:171: l-nb-literal-text
# l-nb-literal-text(n) ::=
#   l-empty(n,block-in)*
#   s-indent(n) nb-char+

l-nb-literal-text:
  (...): n
  (all):
  - (***): { l-empty: [ n, "block-in" ] }
  - s-indent: n
  - (+++): nb-char



:172: b-nb-literal-next
# b-nb-literal-next(n) ::=
#   b-as-line-feed
#   l-nb-literal-text(n)

b-nb-literal-next:
  (...): n
  (all):
  - b-as-line-feed
  - l-nb-literal-text: n



:173: l-literal-content
# l-literal-content(n,t) ::=
#   ( l-nb-literal-text(n)
#   b-nb-literal-next(n)*
#   b-chomped-last(t) )?
#   l-chomped-empty(n,t)

l-literal-content:
  (...): [ n, t ]
  (all):
  - (???):
      (all):
      - l-nb-literal-text: n
      - (***): { b-nb-literal-next: n }
      - b-chomped-last: t
  - l-chomped-empty: [ n, t ]



##### 8.1.3. Folded Style


:174: c-l+folded
# c-l+folded(n) ::=
#   '>' c-b-block-header(m,t)
#   l-folded-content(n+m,t)

c-l+folded:
  (...): n
  (all):
  - '>'
  - c-b-block-header: [ m, t ]
  - l-folded-content: [ { (+): [ n, m ] }, t ]



:175: s-nb-folded-text
# s-nb-folded-text(n) ::=
#   s-indent(n) ns-char
#   nb-char*

s-nb-folded-text:
  (...): n
  (all):
  - s-indent: n
  - ns-char
  - (***): nb-char



:176: l-nb-folded-lines
# l-nb-folded-lines(n) ::=
#   s-nb-folded-text(n)
#   ( b-l-folded(n,block-in) s-nb-folded-text(n) )*

l-nb-folded-lines:
  (...): n
  (all):
  - s-nb-folded-text: n
  - (***):
      (all):
      - b-l-folded: [ n, "block-in" ]
      - s-nb-folded-text: n



:177: s-nb-spaced-text
# s-nb-spaced-text(n) ::=
#   s-indent(n) s-white
#   nb-char*

s-nb-spaced-text:
  (...): n
  (all):
  - s-indent: n
  - s-white
  - (***): nb-char



:178: b-l-spaced
# b-l-spaced(n) ::=
#   b-as-line-feed
#   l-empty(n,block-in)*

b-l-spaced:
  (...): n
  (all):
  - b-as-line-feed
  - (***): { l-empty: [ n, "block-in" ] }



:179: l-nb-spaced-lines
# l-nb-spaced-lines(n) ::=
#   s-nb-spaced-text(n)
#   ( b-l-spaced(n) s-nb-spaced-text(n) )*

l-nb-spaced-lines:
  (...): n
  (all):
  - s-nb-spaced-text: n
  - (***):
      (all):
      - b-l-spaced: n
      - s-nb-spaced-text: n



:180: l-nb-same-lines
# l-nb-same-lines(n) ::=
#   l-empty(n,block-in)*
#   ( l-nb-folded-lines(n) | l-nb-spaced-lines(n) )

l-nb-same-lines:
  (...): n
  (all):
  - (***): { l-empty: [ n, "block-in" ] }
  - (any):
    - l-nb-folded-lines: n
    - l-nb-spaced-lines: n



:181: l-nb-diff-lines
# l-nb-diff-lines(n) ::=
#   l-nb-same-lines(n)
#   ( b-as-line-feed l-nb-same-lines(n) )*

l-nb-diff-lines:
  (...): n
  (all):
  - l-nb-same-lines: n
  - (***):
      (all):
      - b-as-line-feed
      - l-nb-same-lines: n



:182: l-folded-content
# l-folded-content(n,t) ::=
#   ( l-nb-diff-lines(n)
#   b-chomped-last(t) )?
#   l-chomped-empty(n,t)

l-folded-content:
  (...): [ n, t ]
  (all):
  - (???):
      (all):
      - l-nb-diff-lines: n
      - b-chomped-last: t
  - l-chomped-empty: [ n, t ]



### 8.2. Block Collection Styles


##### 8.2.1. Block Sequences


#===============================================================================
# The <auto-detect-indent> rule is a "special" rule that finds the new level of
# indentation and returns the number of columns. The level must be greater than
# 0. It does not consume the indentation.
#===============================================================================

:183: l+block-sequence
# l+block-sequence(n) ::=
#   ( s-indent(n+m)
#   c-l-block-seq-entry(n+m) )+
#   <for_some_fixed_auto-detected_m_>_0>

l+block-sequence:
  (...): n
  (all):
  - (set): [ m, <auto-detect-indent> ]
  - (+++):
      (all):
      - s-indent: { (+): [ n, m ] }
      - c-l-block-seq-entry: { (+): [ n, m ] }



:184: c-l-block-seq-entry
# c-l-block-seq-entry(n) ::=
#   '-' <not_followed_by_an_ns-char>
#   s-l+block-indented(n,block-in)

c-l-block-seq-entry:
  (...): n
  (all):
  - '-'
  - (!==): ns-char
  - s-l+block-indented: [ n, "block-in" ]



:185: s-l+block-indented
# s-l+block-indented(n,c) ::=
#   ( s-indent(m)
#   ( ns-l-compact-sequence(n+1+m)
#   | ns-l-compact-mapping(n+1+m) ) )
#   | s-l+block-node(n,c)
#   | ( e-node s-l-comments )

s-l+block-indented:
  (...): [ n, c ]
  (any):
  - (all):
    - s-indent: m
    - (any):
      - ns-l-compact-sequence: { (+): [ n, { (+): [ 1, m ] } ] }
      - ns-l-compact-mapping: { (+): [ n, { (+): [ 1, m ] } ] }
  - s-l+block-node: [ n, c ]
  - (all):
    - e-node
    - s-l-comments



:186: ns-l-compact-sequence
# ns-l-compact-sequence(n) ::=
#   c-l-block-seq-entry(n)
#   ( s-indent(n) c-l-block-seq-entry(n) )*

ns-l-compact-sequence:
  (...): n
  (all):
  - c-l-block-seq-entry: n
  - (***):
      (all):
      - s-indent: n
      - c-l-block-seq-entry: n



##### 8.2.2. Block Mappings


:187: l+block-mapping
# l+block-mapping(n) ::=
#   ( s-indent(n+m)
#   ns-l-block-map-entry(n+m) )+
#   <for_some_fixed_auto-detected_m_>_0>

l+block-mapping:
  (...): n
  (all):
  - (set): [ m, <auto-detect-indent> ]
  - (+++):
      (all):
      - s-indent: { (+): [ n, m ] }
      - ns-l-block-map-entry: { (+): [ n, m ] }



:188: ns-l-block-map-entry
# ns-l-block-map-entry(n) ::=
#   c-l-block-map-explicit-entry(n)
#   | ns-l-block-map-implicit-entry(n)

ns-l-block-map-entry:
  (...): n
  (any):
  - c-l-block-map-explicit-entry: n
  - ns-l-block-map-implicit-entry: n



:189: c-l-block-map-explicit-entry
# c-l-block-map-explicit-entry(n) ::=
#   c-l-block-map-explicit-key(n)
#   ( l-block-map-explicit-value(n)
#   | e-node )

c-l-block-map-explicit-entry:
  (...): n
  (all):
  - c-l-block-map-explicit-key: n
  - (any):
    - l-block-map-explicit-value: n
    - e-node



:190: c-l-block-map-explicit-key
# c-l-block-map-explicit-key(n) ::=
#   '?'
#   s-l+block-indented(n,block-out)

c-l-block-map-explicit-key:
  (...): n
  (all):
  - '?'
  - s-l+block-indented: [ n, "block-out" ]



:191: l-block-map-explicit-value
# l-block-map-explicit-value(n) ::=
#   s-indent(n)
#   ':' s-l+block-indented(n,block-out)

l-block-map-explicit-value:
  (...): n
  (all):
  - s-indent: n
  - ':'
  - s-l+block-indented: [ n, "block-out" ]



:192: ns-l-block-map-implicit-entry
# ns-l-block-map-implicit-entry(n) ::=
#   (
#   ns-s-block-map-implicit-key
#   | e-node )
#   c-l-block-map-implicit-value(n)

ns-l-block-map-implicit-entry:
  (...): n
  (all):
  - (any):
    - ns-s-block-map-implicit-key
    - e-node
  - c-l-block-map-implicit-value: n



:193: ns-s-block-map-implicit-key
# ns-s-block-map-implicit-key ::=
#   c-s-implicit-json-key(block-key)
#   | ns-s-implicit-yaml-key(block-key)

ns-s-block-map-implicit-key:
  (any):
  - c-s-implicit-json-key: "block-key"
  - ns-s-implicit-yaml-key: "block-key"



:194: c-l-block-map-implicit-value
# c-l-block-map-implicit-value(n) ::=
#   ':' (
#   s-l+block-node(n,block-out)
#   | ( e-node s-l-comments ) )

c-l-block-map-implicit-value:
  (...): n
  (all):
  - ':'
  - (any):
    - s-l+block-node: [ n, "block-out" ]
    - (all):
      - e-node
      - s-l-comments



:195: ns-l-compact-mapping
# ns-l-compact-mapping(n) ::=
#   ns-l-block-map-entry(n)
#   ( s-indent(n) ns-l-block-map-entry(n) )*

ns-l-compact-mapping:
  (...): n
  (all):
  - ns-l-block-map-entry: n
  - (***):
      (all):
      - s-indent: n
      - ns-l-block-map-entry: n



##### 8.2.3. Block Nodes


:196: s-l+block-node
# s-l+block-node(n,c) ::=
#   s-l+block-in-block(n,c) | s-l+flow-in-block(n)

s-l+block-node:
  (...): [ n, c ]
  (any):
  - s-l+block-in-block: [ n, c ]
  - s-l+flow-in-block: n



:197: s-l+flow-in-block
# s-l+flow-in-block(n) ::=
#   s-separate(n+1,flow-out)
#   ns-flow-node(n+1,flow-out) s-l-comments

s-l+flow-in-block:
  (...): n
  (all):
  - s-separate: [ { (+): [ n, 1 ] }, "flow-out" ]
  - ns-flow-node: [ { (+): [ n, 1 ] }, "flow-out" ]
  - s-l-comments



:198: s-l+block-in-block
# s-l+block-in-block(n,c) ::=
#   s-l+block-scalar(n,c) | s-l+block-collection(n,c)

s-l+block-in-block:
  (...): [ n, c ]
  (any):
  - s-l+block-scalar: [ n, c ]
  - s-l+block-collection: [ n, c ]



:199: s-l+block-scalar
# s-l+block-scalar(n,c) ::=
#   s-separate(n+1,c)
#   ( c-ns-properties(n+1,c) s-separate(n+1,c) )?
#   ( c-l+literal(n) | c-l+folded(n) )

s-l+block-scalar:
  (...): [ n, c ]
  (all):
  - s-separate: [ { (+): [ n, 1 ] }, c ]
  - (???):
      (all):
      - c-ns-properties: [ { (+): [ n, 1 ] }, c ]
      - s-separate: [ { (+): [ n, 1 ] }, c ]
  - (any):
    - c-l+literal: n
    - c-l+folded: n



:200: s-l+block-collection
# s-l+block-collection(n,c) ::=
#   ( s-separate(n+1,c)
#   c-ns-properties(n+1,c) )?
#   s-l-comments
#   ( l+block-sequence(seq-spaces(n,c))
#   | l+block-mapping(n) )

s-l+block-collection:
  (...): [ n, c ]
  (all):
  - (???):
      (all):
      - s-separate: [ { (+): [ n, 1 ] }, c ]
      - c-ns-properties: [ { (+): [ n, 1 ] }, c ]
  - s-l-comments
  - (any):
    - l+block-sequence: { seq-spaces: [ n, c ] }
    - l+block-mapping: n



:201: seq-spaces
# seq-spaces(n,c) ::=
#   ( c = block-out => n-1 )
#   ( c = block-in => n )

seq-spaces:
  (...): [ n, c ]
  (flip):
    var: c
    "block-in": n
    "block-out": { (-): [ n, 1 ] }



### 9.1. Documents


##### 9.1.1. Document Prefix


:202: l-document-prefix
# l-document-prefix ::=
#   c-byte-order-mark? l-comment*

l-document-prefix:
  (all):
  - (???): c-byte-order-mark
  - (***): l-comment



##### 9.1.2. Document Markers


:203: c-directives-end
# c-directives-end ::=
#   '-' '-' '-'

c-directives-end:
  (all):
  - '-'
  - '-'
  - '-'



:204: c-document-end
# c-document-end ::=
#   '.' '.' '.'

c-document-end:
  (all):
  - '.'
  - '.'
  - '.'



:205: l-document-suffix
# l-document-suffix ::=
#   c-document-end s-l-comments

l-document-suffix:
  (all):
  - c-document-end
  - s-l-comments



:206: c-forbidden
# c-forbidden ::=
#   <start_of_line>
#   ( c-directives-end | c-document-end )
#   ( b-char | s-white | <end_of_file> )

c-forbidden:
  (all):
  - <start-of-line>
  - (any):
    - c-directives-end
    - c-document-end
  - (any):
    - b-char
    - s-white
    - <end-of-stream>



##### 9.1.3. Bare Documents


#===============================================================================
# The l-bare-document is the topmost rule for parsing a document.
#
# The <excluding_c-forbidden_content> says that in every other rule you must
# check that c-forbidden does not occur.
#
# This is a bad design choice for a formal grammar.
#===============================================================================

:207: l-bare-document
# l-bare-document ::=
#   s-l+block-node(-1,block-in)
#   <excluding_c-forbidden_content>

l-bare-document:
  (all):
  - (exclude): c-forbidden
  - s-l+block-node: [ -1, "block-in" ]



##### 9.1.4. Explicit Documents


:208: l-explicit-document
# l-explicit-document ::=
#   c-directives-end
#   ( l-bare-document
#   | ( e-node s-l-comments ) )

l-explicit-document:
  (all):
  - c-directives-end
  - (any):
    - l-bare-document
    - (all):
      - e-node
      - s-l-comments



##### 9.1.5. Directives Documents


:209: l-directive-document
# l-directive-document ::=
#   l-directive+
#   l-explicit-document

l-directive-document:
  (all):
  - (+++): l-directive
  - l-explicit-document



### 9.2. Streams


:210: l-any-document
# l-any-document ::=
#   l-directive-document
#   | l-explicit-document
#   | l-bare-document

l-any-document:
  (any):
  - l-directive-document
  - l-explicit-document
  - l-bare-document



:211: l-yaml-stream
# l-yaml-stream ::=
#   l-document-prefix* l-any-document?
#   ( ( l-document-suffix+ l-document-prefix*
#   l-any-document? )
#   | ( l-document-prefix* l-explicit-document? ) )*

l-yaml-stream:
  (all):
  - (***): l-document-prefix
  - (???): l-any-document
  - (***):
      (any):
      - (all):
        - (+++): l-document-suffix
        - (***): l-document-prefix
        - (???): l-any-document
      - (all):
        - (***): l-document-prefix
        - (???): l-explicit-document

# vim: iskeyword=@,+,- sw=2:
